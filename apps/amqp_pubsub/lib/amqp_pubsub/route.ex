defmodule AmqpPubsub.Route do
  require Logger
  alias AmqpPubsub.Registry
  use GenServer

  def start_link(opts \\ []) do
    GenServer.start_link(__MODULE__, :ok, opts)
  end


  @doc """
  Parses route config Keyword list with :route and optional :name key.
  Returns MQTT subscription path and Google Cloud Pub/Sub Topic name.
  Google Cloud Pub/Sub name is either automatically derived, or explicitly
  provided in :name key.
  """
  def parse(route_config) do
    case Keyword.fetch(route_config, :route) do
      :error ->
        Logger.debug("Bad route config: #{inspect route_config}")
        {:error, "route not found"}
      {:ok, route} ->
        amqp_subscription = route_config_to_amqp_subscription(route)

        subscription_name = case Keyword.fetch(route_config, :name) do
          {:ok, name} -> name
          :error -> route_config_to_pubsub_topic(route)
        end

        topic_parser_config = get_topic_parameter_parser_config(route)

        {:ok, %{route: route, amqp_subscription: amqp_subscription, subscription_name: subscription_name, topic_parser_config: topic_parser_config}}
    end
  end

  def route_config_to_pubsub_topic(route) do
    route |> String.replace("/", ".") |> String.replace("#", "~")
  end

  def route_config_to_amqp_subscription(route) do
    segments = String.split(route, "/")
    Enum.map(segments, &parse_route_config_segment/1) |> Enum.join(".")
  end

  # TODO: validate that multi-level wildcard # is in last segment
  def parse_route_config_segment("+" <> segment), do: "*"
  def parse_route_config_segment("#" <> segment), do: "#"
  def parse_route_config_segment(segment), do: segment


  @doc """
  Creates list of topic parameter (wildcard) names per index location
  in path, using nil for non-wildcard path parts and removing extraneous nils
  at tail of list since we ignore nils when extracting paramters from the topic.

  Also returns number of parts to split path into. By limiting the number of parts
  in String.split, we can grab the rest of the paths in the topic (effectively
  grabbing the multi-level wildcard subscription portion).

  If no named is supplied for the wildcard subscription in the route, then
  a name is autogenerated.

  Returns a Map of params list and parts to String.split.

  ## Examples

    iex> AmqpPubsub.Route.get_topic_parameter_parser_config("gateway/+gateway_id/tank/+tank_id/temperature")
    %{params: [nil, "gateway_id", nil, "tank_id"], parts: 5}

    iex> AmqpPubsub.Route.get_topic_parameter_parser_config("gateway/+gateway_id/#")
    %{params: [nil, "gateway_id", "topic_remainder"], parts: 3}

  """
  def get_topic_parameter_parser_config(route) do
    paths = Enum.with_index(String.split(route, "/"))
    %{
      params:
        Enum.reduce(paths, [],
          fn
            {"+" <> "", index}, acc -> [ "param_#{index}" | acc ]
            {"+" <> x, _}, acc -> [ x | acc ]
            {"#" <> "", _}, acc -> [ "topic_remainder" | acc ]
            {"#" <> x, _}, acc -> [ x | acc ]
            _, acc -> [ nil | acc]
          end) |> Enum.drop_while(&(is_nil(&1))) |> Enum.reverse,
      parts:
        Enum.count paths
    }
  end

  @doc """
  Parses topic parameters from AMQP topic (analagous to MQTT topic).

  ## Examples

    iex > AmqpPubsub.Route.parse_topic_parameters("gateway.gw123.tank.t455.temperature", %{params: [nil, "gateway_id", "topic_remainder"], parts: 3})
    [{"gateway_id", "gw123"}, {"topic_remainder", "tank/t455/temperature"}]
  """
  def parse_topic_parameters(amqp_topic, config) do
    topic = amqp_to_mqtt_topic(amqp_topic)
    Stream.zip(config.params, String.split(topic, "/", parts: config.parts)) |> Enum.filter(fn {p, t} -> not is_nil(p) end)
  end

  def amqp_to_mqtt_topic(amqp_topic) do
    amqp_topic |> String.replace(".", "/")
  end

  def create_routes() do
    routes = Application.get_env(:amqp_pubsub, :routes)
    Logger.debug("Parsing routes: #{inspect routes}")
    for route_config <- Application.get_env(:amqp_pubsub, :routes) do
      parse(route_config)
    end |> Enum.filter_map(fn({status, _}) -> status == :ok end, fn({_, route}) -> route end)
  end


  def init(:ok) do
    routes = create_routes()

    for route <- routes do
      Registry.create(AmqpPubsub.Registry, route)
    end

    {:ok, routes}
  end


end
